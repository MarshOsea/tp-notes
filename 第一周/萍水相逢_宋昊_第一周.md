如何通过代码技巧提升内存使用效率


Java的JVM有一套自己的垃圾回收机制来回收内存，在一般情况下是不需要我们来操心内存垃圾回收问题的，但是java程序也会出现内存泄漏的问题，那么如何通过代码技巧提升内存使用效率呢。

GC工作原理：监控每一个对象的运行状态，包括对象的申请、引用、被引用、赋值等，当该对象不再被引用时，释放对象。

怎样在代码中优化内存使用：

1、一些物理对象， 比如IO对象 数据库的连接对象在使用好以后，需要把他们close或者clear掉；一般可以用try-catch-finally 的样式来使用connection或IO等对象 可以在finally从句中关闭这些对象

2、当用好一块对象，应该把它设为null

3、string对象属于不可变对象，尽量避免频繁对它进行操作，不应该在循环或者说在多线程里频繁对string进行操作。如果场景需要，可以使用StringBuilder或StringBuffer来替代String

4、当我们用好集合对象时，我们应该及时把它clear掉 list.clear()

通过参数配置进行JVM优化：

-Xms 堆内存的最小大小，默认为物理内存的1/64

-Xmx 堆内存的最大大小，默认为物理内存的1/4

-Xss 设置每个线程可使用的内存大小，即栈的大小。在相同物理内存下，减小这个值能生成更多的线程，当然操作系统对一个进程内的线程数还是有限制的，不能无限生成。线程栈的大小是个双刃剑，如果设置过小，可能会出现栈溢出，特别是在该线程内有递归、大的循环时出现溢出的可能性更大，如果该值设置过大，就有影响到创建栈的数量，如果是多线程的应用，就会出现内存溢出的错误。

-Xmn 堆内新生代的大小。通过这个值也可以得到老年代的大小：-Xmx减去-Xmn

-XX:NewRatio 设置新生代和老年代的比值。如：为3，表示年轻代与老年代比值为1：3

-XX:SurvivorRatio 新生代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：为3，表示Eden：Survivor=3：2，一个Survivor区占整个新生代的1/5  

-XX:MaxTenuringThreshold 设置转入老年代的存活次数。如果是0，则直接跳过新生代进入老年代

-XX:PermSize、-XX:MaxPermSize 分别设置永久代最小大小与最大大小（Java8以前）

-XX:MetaspaceSize、-XX:MaxMetaspaceSize 分别设置元空间最小大小与最大大小（Java8以后，目前微服务平台使用的JDK1.8.191）

----------------------------------------------------------------------------------------------------------------

如何从java线程内存模型角度分析线程是否安全


1、在Java语言中，采用的是共享内存模型来实现多线程之间的信息交换和数据同步的。既Java内存模型规定了所有的变量都存储在主内存(Main Memory)中。每条线程还有自己的工作内存(Working Memory)，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作(读取，赋值等)都必须是工作内存中进行，而不能直接读写主内存中的变量。线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。

【关于Java模型可以看东哥分享的《java内存模型》，主要包括read（读取）-> load（载入）-> use（使用）-> assign（赋值）-> store（存储）-> write（写入）几个过程】

2、线程安全是要耗费资源的，而且很多都是单线程，所以如果没有必要的话是不用线程安全对象的

3、volatile是不能保证线程安全的 但是可以提高性能

可以做到立即读立即写，但是没法保证原子性

作用：可以减少从主内存中读与写的步骤。

如果只对这个变量进行写，或者读 就可以通过volatile来提高性能

----------------------------------------------------------------------------------------------------------------

JVM问题定位典型案例分析

本视频主要讲了四个案例

1、类加载-死锁 Java 类加载还会死锁？

2、FinalReference 堆积 jmap java.lang.ref.Finalizer对象 finalize方法 FinalReference 对象及引用对象何时被回收
 
3、堆外内存-泄露

heap使用率很低，但是出现了OOM或者FullGC

java.lang.OutMemoryError:Direct buffer memory

MaxDirectMemorySize

使用bTrace追踪DrrectByteBuffer

4、YGC-不断拉长YGC主要分三个步骤：mark copy sweep

mark和copy是同时进行的

被mark的对象的多少直接影响了耗时多少


