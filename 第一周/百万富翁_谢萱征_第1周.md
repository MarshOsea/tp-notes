## WebAssembly技术
-----
## 1. 什么是WebAssembly？  

    或许大家都知道webAssembly执行的更快，但是究竟为什么，可能很多人还不知道。   
    WebAssembly 是除了JavaScript以外，另一个可以在浏览器中执行的编程语言，在实际工程中，二者可以同时使用。  
> 2008年之前，JavaScript一直运行比较慢，直到08年以后，许多浏览器引入了 *Just-in-time* 编译器，自此，基于 ***JIT*** 的模式，Javascript代码的运行渐渐变快了,也用到了更广泛的地方，现在出现了WebAssembly，可能是另外一个拐点的到来。 
----- 
    
## 2. JIT工作原理  
> 人与机器交流需要翻译机器语言： **解释器 和 编译器**  
**`解释器`**：翻译是一行一行地边解释边执行。优点：启动快执行快无需等待，缺点： 循环中的代码每次重新解释，效率低  
**`编译器`**: 把源代码整个编译成目标代码，执行时不再需要编译器，直接在支持目标代码的平台上运行。  
**`JIT`**: 解释器效率低，浏览器就把编译器也引入进来，形成 ***混合模式*** ，基本方式就是在JavaScript引擎中增加一个监视器(分析器)，监视器监控着代码的运行情况，记录代码一共运行了多少次，如何运行的等这些信息，如果一行代码运行了几次，这个代码段就标记成 `warm`，如果很多次，就标记为`hot`。  
**`基线编译器`**:如果一段代码变成了"warm", 那么JIT就把它送到编译器中进行编译，代码段的每一行都会被编译成一个"桩(stub)"，然后用"行号+变量类型"的索引标记，如果监视器监视到了执行同样的代码和同样的变量类型，那么就把已编译的版本push出来给浏览器.基线编译器可以做一部分优化，但是不能太久，要不然程序会卡住。  
**`优化编译器`**: 如果一个代码段变得“very hot”，那么监视器就会把它们送到优化编译器中，生成一个更高效和快速的代码版本然后存起来，这个过程叫做优化，在进行优化的过程中，如果发现失败了，就会执行去优化操作。  

JIT增加的开销：  
 * 优化去优化的开销  
 * 监视器记录信息的开销  
 * 发生去优化情况时恢复信息的记录对内存的开销  
 * 对基线版本和优化版本记录的内存开销 
-----

## 3. 汇编原理 
    编译器的工作：将高级语言翻译成机器语言（编译器前端把高级语言翻译到IR,编译器后端把IR翻译成目标机器的汇编代码）
-----  

## 4.  WebAssembly的工作原理  
 #### 4.1  简介： 
 WebAssembly和JavaScript是可以兼容的，在JavaScript代码中引入WebAssembly功能模块，编译器的作用是把高级语言翻译成机器码，webAssembly是一种概念机器语言，而不是实际的物理机器的语言，处于中间代码(Intermediate respresentation, IR)之后，WebAssembly也称为虚拟指令,Javascript中引入.wasm模块：
 ```
1 function fetchAndInstantiate(url, importObject) {
2   return fetch(url).then(response =>
3     response.arrayBuffer()
4   ).then(bytes =>
5     WebAssembly.instantiate(bytes, importObject)
6   ).then(results =>
7     results.instance
8   );
9 }

 ```  
 #### 4.2 .wasm文件   
对WebAssembly支持情况最好的编译器工具链是LLVM，很多前端和后端插件可以用在LLVM上，可以使用C或者Rust开发，再编译成WebAssembly，TypeScript、或者直接使用文本格式都可以开发WebAssembly模块,无论使用哪种语言，最终目的是生成.wasm文件
#### 4.3 .wasm文件结构 
Web 
如果只是高级语言开发者，并且通过编译器生成WebAssembly，那么不必关心内部实现，可以大概作为了解,下面代码是可以生成WebAssembly模块的C语言代码： 

```
int add42(int num) {
    return num + 42;
}
```
编译成WebAssembly文件如下：
```
00 61 73 6D 0D 00 00 00 01 86 80 80 80 00 01 60
01 7F 01 7F 03 82 80 80 80 00 01 00 04 84 80 80
80 00 01 70 00 00 05 83 80 80 80 00 01 00 01 06
81 80 80 80 00 00 07 96 80 80 80 00 02 06 6D 65
6D 6F 72 79 02 00 09 5F 5A 35 61 64 64 34 32 69
00 00 0A 8D 80 80 80 00 01 87 80 80 80 00 00 20
00 41 2A 6A 0B
```
`20 00`  获取第一个参数的值然后push到栈里  
`41 2A`  push一个常数42到栈里  
`6A`  把上面两个数相加然后把结果push到栈里，  
所有的操作符都知道自己需要几个值，+号就会自动去栈里的两个值

#### 4.4 WebAssembly模块的组成部分  
1. Type 在模块中定义的函数声明  
2. Function 函数索引  
3. Code 实际函数体  
-----

 ## 5.为什么更快？
 一旦JavaScript引擎发现执行的是asm.js，就知道这是经过优化过的代码，可以跳过语法分析这一步，直接转为汇编语言，另外浏览器还会调用webGL通过GPU执行asm.js

#### 5.1 javascript在js引擎中的执行时间
* parsing-源代码变成解释器可以运行的代码所需时间  
* compiling + optimizing： 基线编译器和优化编译器所耗时间  
* reoptimizing: JIT发生假设错误，重新优化的时间 
* execution： 执行代码的时间 
* garbage collection 垃圾回收，清理内存

#### 5.2 文件获取 
压缩效率高，可以减小包的大小，传输速度更快

#### 5.3 解析
JavaScript代码被解析成抽象语法树(AST)，AST再提供给JS引擎编译，而web Assembly不需要解析成AST，直接就可以给JS引擎编译，本身就是中间代码

#### 5.4 编译和优化 

因为JavaScript语言是弱类型，变量发生了变化，同样的代码被编译成不同的版本，而WebAssembly更贴近机器语言，不会被编译成不同版本  
* 编译优化代码之前，不需要提前运行代码先要知道变量的类型
* 编译器不会对同样的代码编译成不同的版本
* 很多优化再LLVM阶段就完成了，再次编译和优化的时候不需要做过多的工作

#### 5.5 重优化
JIT会重复执行`抛弃优化代码 ->  再优化`的这个过程, 1 需要时间抛弃已优化的代码并且回到基线版本。2 如果再次调用这个代码块，就又一次的执行之前的无用功，而在WebAssembly中，类型都是确定的，就不会出现重优化的过程

#### 5.6 执行
开发人员所写的JavaScript代码并不能完全符合JIT执行标准，所以会出现资源浪费的情况，而WebAssembly本身就是为编译器所设计，执行效率方面，一般来讲会提高10%-800%

#### 5.7 垃圾回收
JavaScript中开发者无需手动清理内存，Javascript引擎会自动清理，这个过程叫`垃圾回收`，正因为它是自动启动回收机制，所以并不能保证是在最合适的时机启动，不可控   
WebAssembly不支持自动回收，可以实现手动操作，增加了成本，也可以适当提高效率  ----

## 6. WebAssembly的现在与未来 

2017年四大浏览器宣布支持WebAssembly的MVP版本，目前开发者已经可以使用该语言了，asm.js是JavaScript的一个子集，所有的JS引擎都已经支持，通过Emscripten工具，可以把应用编译成WebAssembly或者asm.js。  
* 频繁的在JavaScript和WebAssembly之间转换，会降低执行效率
* JIT需要在快速加载和快速执行中做一个平衡
* 未来特性 1 直接操作DOM,目前不能直接操作DOM，需要调用JS的API，JavaScript代码和WebAssembly代码可以互相嵌套 2 共享内存的并发性 3 SIMD（单指令，多数据），对于媒体或者游戏

## 7. 实践
WebAssembly的编译都主要依赖于 ***`Emscripten SDK`*** 这个工具，工具链包含python，cmake，emsdk这几个软件  
安装完成之后，运行命令，可以生成对应的html文件：  
```
emcc hello.c -s WASM=1 -o hello.html

```  
运行命令可以启动服务：
```
emrun --no_browser --port 8080 
```
**至此，一个由C语言写的函数，已经可以在浏览器页面执行了**  
目前已经使用WebAssembly的企业:   
bilibili web投稿，处理视频，AI智能学习等  
腾讯的企业邮箱，上传比较大的文件






  
