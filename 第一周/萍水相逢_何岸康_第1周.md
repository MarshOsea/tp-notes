# 学习笔记

## 1、高并发场景下锁的使用技巧

### 有哪些锁可以使用

- synhroniz
- volatile
- CAS
- 数据库行锁
- 悲观锁和乐观锁
- 分布式锁

### 为什么要使用分布式锁

单体应用演变为跨JVM或者跨进程的实例部署，就无法使用java的锁机制来控制并发了，在这种情况下，为了解决跨JVM的访问部署，就需要有跨JVM的互斥访问机制来控制共享资源的访问，这时候就需要引入分布式锁。

#### 乐观锁和乐观锁

- 悲观锁：每次拿共享数据时加锁。
synchronize，数据库行锁
- 乐观锁：每次过去共享数据时，不上锁，更新时会上锁，数据库版本号，JVM CAS机制。
cas，数据库版本号

#### 余额扣减操作中锁的使用

示例伪代码：

```java
//扣减导致的超卖
reduce(){
    select total_amount from table_1
    if (total_amount < amount) {
        return failed.
    }
    // business logic
    update total_amount = total_amount - amount;
}
```

1. synchronize同步锁方案
   - 缺点1：线程串行导致的性能问题，性能消耗比较大。
   - 缺点2：无法解决分布式部署情况下跨进程、跨JVM问题。
2. 数据库行锁方案
   - 解决了分布式问题
   - 缺点1：性能问题。在数据库层面，select for update会一直阻塞直到事务提交，这里也是串行操作。
   - 缺点2：需要注意设置事务的隔离级别是Read Committed，否则并发情况下，另外的事务无法看到提交的数据，依然会导致超卖问题。
   - 缺点3：容易打满数据库连接。如果事务中有第三方接口交互，会导致这个事务的连接一直阻塞，打满数据库连接。
   - 缺点4：容易产生交叉死锁，如果多个业务的加锁顺序控制不好，就会发生AB两条记录的交叉死锁。
3. Redis做分布式锁
   - 引入Redis分布式锁可以避免大量对数据库拍他锁的征用，提高系统的相应能力。
Redis分布式锁需要注意的点：
      - 设置锁和设置超时时间的原子性
      setnx和expire是两个指令，不具备原子性。可使用`set key-with-expire-time "hello" EX 10000`
      - 不设置超时时间的缺点
      如果服务宕机锁永远不失效
      - 服务宕机或者线程阻塞超时的情况
      - 超时时间设置不合理的情况
      续命锁：建立一个守护线程去继续加锁（更复杂）
4. 数据库乐观锁方案
修改代码为：

```java
reduce(){
    int num = update total_amount = total_amount - amount where total_amount >= amount;
    if(num ==1){
        // business logic
    }else{
        throw Exception;
    }  
}
```

## 2、微服务架构体系的深度治理

> 微服务模式下，庞大的服务节点数量、日趋复杂的服务分层、离散的组织协同、扁平化的管理模式让服务治理的广度、深度、难度都达到前所未有的程度。单纯依靠微服务框架层面的治理是远远不够的，需要构建贯穿研发、测试、运维、管理各领域的立体式的深度治理体系。本文整理自天弘基金（余额宝）移动平台技术总监兼首席架构师李鑫在 QCon 全球软件开发大会（北京站）2019 上的演讲，他基于自身多年微服务治理的实践经验及感悟，全面地介绍了如何构建完备的微服务治理的指标体系及治理模型，并通过自动化的线上线下一体的“度量”及“管控”这两大能力的构建来综合解决微服务全生命周期的现实治理需求。

![目录](https://gitee.com/heankang/pico/raw/master/img/20200214104650.png)

“治理”这个词，在汉语词典中是“整治、修整”的意思。任何一个事物，当它的复杂度达到一定程度时，就可能出现问题，我们需要对问题进行梳理、改进和优化。因此，对事物的治理，本质上是对事物复杂度的管理。同样的，服务治理就是对服务复杂度膨胀问题的管控及管理。

### 服务治理发展简史

- 单体应用
  - 没有服务概念，所以谈不上服务治理
  - 复杂度来自于自身的组件，衍生出组建治理
- 企业级SOA
  - 已有系统之间有了互联互通及整合的需求
  - 技术实现几流程繁琐复杂，实现成本高
  - 覆盖面广，覆盖企业IT各方面
  - 传统IT大厂把持标准
  - 手工治理比重大
- 互联网服务化
  - 伴随业务拆分应用而生
  - 主要解决业务的快速响应与系统复杂性扩散问题
  - 有标杆，没有统一标准
  - 聚焦线上服务的生命周期治理
  - 强调自动化
- 微服务
  - 大平台、微服务
  - 和容器技术紧密相连
  - 量变导致质变，我们的开发模式、测试模式、运维模式都会受到冲击。
  - 线上线下一体，全生命周期的立体化治理
  - 强调自动化智能化。

#### 微服务治理整体架构：三位一体的体系

微服务的治理既要进行线上的治理，也要进行线下的治理，通过线上线下两大维度进行治理指标的采集，并把它汇总到数据仓库中，进行统一的度量和分析。
![三位一体](https://gitee.com/heankang/pico/raw/master/img/20200214114406.png)
这些度量指标中，有相当一部分线上的性能及异常指标会被转化为运维事件，一旦触发我们预先设置的阈值，就会被进一步转化成“管控指令”，并通过调度中心下发，进行服务的弹性伸缩、扩容缩容操作，或者进行服务的限流、降级、容错、路由调整等管控操作。

另外一部分度量指标，包括架构、开发、测试、运维、过程协作效率等指标会通过治理委员会（泛指，治理成员的集合）进行人为的深入分析，并制定出治理决策，这些治理决策会通过相关的管理措施进行落地。

这样，我们就通过服务的度量、管控、管理这三大举措，构建起一个三位一体、围绕服务治理的闭环体系。

### 微服务度量

![度量](https://gitee.com/heankang/pico/raw/master/img/20200214114617.png)

#### 微服务全生命周期度量指标采集

度量的第一步，就是度量指标的采集。微服务的治理囊括了线上及线下体系，同样的，服务治理度量指标的采集也要线上线下同步进行。
![度量](https://gitee.com/heankang/pico/raw/master/img/20200214114959.png)
有了以上这些线上线下指标，就可以将它们统一汇总到数据仓库，进行进一步的深度度量和分析。

还少点什么？？？

#### 通过代码来“理解”代码

![源代码](https://gitee.com/heankang/pico/raw/master/img/20200214115138.png)
针对源码仓库中所有工程源码进行统一扫描的工具。它的核心是AST组件（Abstract Syntax Tree，中文为抽象语法树），通过 AST，可以获取到源码工程中任何一个Java源码文件中所调用的外部类、继承或者实现的接口（父类）、类变量集合、类方法集合、方法逻辑块（多层嵌套）、注释等等基本信息，有了这些基本信息之后，就可以构建出一个跨工程、方法一级的非常庞大的调用关系矩阵，微服务之间的调用关系则是这个调用矩阵的一个子集。这个调用关系矩阵和基于动态调用链路跟踪所获取到的调用链路非常类似，我给它起了一个名字叫**静态调用链路**。

### 微服务线上体系治理

#### 服务限流

![服务限流](https://gitee.com/heankang/pico/raw/master/img/20200214115910.png)
集群限流的情况要更复杂一些，首先在各个微服务节点上要有一个计数器，对单位时间片内的调用进行计数，计数值会被定期的汇总到日志中心，由统计分析器进行统一汇总，算出这个时间片的总调用量，集群限流分析器会拿到这个总调用量，并和预先定义的限流阈值进行比对，计算出一个限流比例，这个限流比例会通过服务注册中心下发到各个服务节点上，服务节点基于限流比例会各自算出当前节点对应的最终限流阈值，最后利用单机限流进行流控。

#### 集群容错

![集群容错](https://gitee.com/heankang/pico/raw/master/img/20200214120056.png)
在使用集群容错的时候，一定要设置最大重试次数。

#### 服务降级、熔断

![服务降级、熔断](https://gitee.com/heankang/pico/raw/master/img/20200214120149.png)
在使用服务降级之前一定要做好预案，你要提前梳理出核心业务链路和非核心业务链路，然后通过降级开关一键把部分或所有非核心链路降级，这样才能救命。
服务降级也有很多手段可以使用，包括：

- 容错降级
- 静态返回值降级
- Mock 降级
- 备用服务降级

#### 故障定界定位

![故障定界定位](https://gitee.com/heankang/pico/raw/master/img/20200214120357.png)
分布式环境下的故障定界定位，最有效的工具就是动态调用链路跟踪
动态调用链要用的好一定是需要和监控大盘相结合。介绍一下我们的使用经验，我们在很早之前就构建了动态调用链跟踪体系，在我们的监控大盘上有很多的点可以进入调用链：

1. 单位时间段内异常最多服务的 TopN 排序列表，点击列表上的任何一个服务，会打开这个服务这个时间段内所有异常的列表，再点击列表上的每一个异常，就会打开这个异常所属调用链，进行故障分析。
2. 可以利用监控大盘，监控大盘上有很多“毛刺”，这些都是系统的一些异常点，点击任何一个“毛刺”，会将“毛刺”所在时间段内的请求以“散点”的形式列出（可能会基于请求数量做抽样），“散点”的颜色代表了不同的状态，有的成功，有的失败。点击任何一个“散点”，就可以进入这个请求对应的调用链。
3. 针对核心服务的异常有专门的一个监控表格，会列出最近发生的核心链路服务上的异常，点击这上面的任何一个异常，也可以进入对应的调用链。

#### 容量规划

![容量规划](https://gitee.com/heankang/pico/raw/master/img/20200214120711.png)

- 容量规划有两种形式，一种是容量预估，另一种是性能压测。
- 线上性能压测首先需要在调用链的末梢，也就是对数据库或者缓存先进行压测，以保证它们不是瓶颈，再对调用数据库或者缓存的上一级节点进行压测，再一级一级往上压测，最终覆盖整个链路，实现全链路压测。
- 全链路压测的前提是单点压测，需要先把单点压测能力做好，才能做全链路压测。
- 在压测的时候，由于流量是模拟的，数据也是“伪造”的，所以一定要做好隔离，各种各样的隔离，尤其是数据的隔离。

#### 资源治理

![资源治理](https://gitee.com/heankang/pico/raw/master/img/20200214120957.png)

- 对于线上任何资源，如果只有服务对它进行调用，那么完全可以基于服务对资源的调用日志来分析资源的使用状况、性能状况。
- 还可以通过服务的调用日志对资源的使用状况进行优化。

#### 线上生命周期管理

![线上生命周期管理](https://gitee.com/heankang/pico/raw/master/img/20200214121322.png)

### 微服务线下体系治理（分享的重点）

#### 架构治理

![架构治理](https://gitee.com/heankang/pico/raw/master/img/20200214121453.png)
这个图是线上微服务集群服务间的调用关系总图，这个图可以通过动态调用链的汇总来获取，目前大部分公司都是这么干的；除此之外，还可以基于静态调用链（调用矩阵）来获得，这个图只是静态调用矩阵的一个子集，通过静态调用链获取到的这个图中的调用关系会比动态调用链更多，有了这个微服务间的整体调用关系之后，我们就可以对微服务的调用质量进行深入的分析。
所有的度量和治理都是在这个调用关系图的基础上进行的，所用的算法也是图计算（图论）中的常用算法，包括 BFS、DFS、PageRank 等等，大家如果嫌麻烦，可以找个图数据库，比如 neo4j，这些算法已经集成在它的基本查询能力中。

##### 单个微服务架构治理

![单个微服务架构治理](https://gitee.com/heankang/pico/raw/master/img/20200214121907.png)

#### 开发治理

![开发治理](https://gitee.com/heankang/pico/raw/master/img/20200214122056.png)

- 基于自定义代码扫描的技术，结合代码的调用关系，我们完全可以做到对跨类和跨方法的调用缺陷进行扫描，比如跨方法的多层循环嵌套，这类缺陷通过常规的代码扫描工具是扫不出来的。
- 除了代码质量之外，还可以结合线上 bug 的种类和数量，来综合评估开发人员的开发质量。
- 进一步汇总个人的质量综合评估报告，可以获得针对团队的开发质量综合评估报告，这两个报告本质上就是个人及团队的研发质量“画像”。

#### 测试治理

![测试治理](https://gitee.com/heankang/pico/raw/master/img/20200214122328.png)

- 微服务架构下的测试治理的两大核心诉求，一个是提高测试的覆盖度，具体说就是提高需求覆盖度、代码覆盖度、页面覆盖度；另外一个则是降低测试用例的维护成本。
- 测试用例的维护成本分两块，一块是新增用例的维护成本，这个比较好度量；比较麻烦的是存量测试用例的变更度度量，我们采用相似度匹配算法，先算出存量测试用例前后两个版本代码的相似度，再换算成变更度。

#### 构建测试能力

![构建测试能力](https://gitee.com/heankang/pico/raw/master/img/20200214122542.png)

- 利用分布式服务框架提供的过滤器机制，开发了一个 Mock 过滤器，通过 Mock 数据文件来详细定义要被 mock 的服务的名称、入参及出参。
- 为了有效降低制作 mock 文件的成本，基于服务框架的过滤器机制开发了“在线数据抓取过滤器”，它可以将指定的服务请求的入参和返回结果都抓取下来，直接写成 mock 数据文件。

#### 协调管理能力

![协调管理能力](https://gitee.com/heankang/pico/raw/master/img/20200214122725.png)

所有指标采集和多维分析和度量，直至最终分析报表的生成要最大可能做成自动化的方式，一键生成，否则，靠“人肉”的方式是无法完成如此繁琐的采集及制作任务、也无法保证时效性。这也是我在前面所强调的自动化及智能化的治理

![总结](https://gitee.com/heankang/pico/raw/master/img/20200214122934.png)

## 3、支付系统中，有哪些技术问题可能会引发资金损失?

- 调支付接口，网络异常等记录记录为处理中。
- 不确定的一定要采取保守策略，不可以直接设置终态.
- 幂等才能重试。
- 查询订单失败单独给响应状态码，不认为是订单失败，人为干预。
- 前后端防重，防止重复订单。
- 数据库，乐观群。
- 状态机防重，有限状态转移。

## 4、如何利用ClassPath解决Java开发工程问题？

- ClassPath是一组搜索类的路径，多个路径之间用';'分割。默认情况下是当前目录。
- 在IDE里启动时，ClassPath的顺序是：
`jdk jar>target/classes>maven dependencies`
- 在测试时，ClassPath的顺序是：
`jdk jar>target/test-classes>target/classes>maven dependencies`
- 对于超长classpath，maven通过创建临时jar里的'META-INF/MANIFEST.MF'里'Class-Path'字段来传递
classpath。