## 第一天 前端监控的实践
### 日志上行连接限制
1、rfc2616规定，同域名同时只能2个连接，rfc7230规定，去掉了具体数字，但其实也是有限制的。  
2、Chrome,同域名限制同时6个连接。  
3、每个请求独占1个连接。
### 日志加速上行的前端策略
1、http2头部压缩技术  
http头部未压缩时，每次请求占用200到800字节，日志仅为10到50字节  
每页上百个统计请求，流量浪费在头部了。  
userAgent、cookies等信息长期不变，每次带过去会很不好。  
http2头部压缩比http1.1,缩小16到18分之一。  
http2头部压缩原理：静态表、动态表分类维护一些头部标准固定字段，复用传输对应编号；其他易变字段，hash算法强制压缩。  
2、其他压缩体积方法  
http 204 no content,不带任何请求体的请求   
post请求合并多条日志  
错误堆栈上报时，其中相同url给抽离成变量。  
3、http2多路复用。  
一个tcp打开多个请求流，双向传输。    
### 数据立方：海量数据处理神器（以空间换时间）
地区、设备型号、浏览器   
其实可以更多维度，几十个维度
## 第二、三天VUE的SFC与AST的深入
### Vue字符串模板缺陷
1、无法高亮，字符串非标签  
2、不易扩展，处理字符串依赖正则，不如处理对象   
3、语义化差，不易维护，大量标签 
### Vue单文件组件SFC优势
1、可以进行语言扩展，template之pug;script之babel、ts;style之stylus、less、sass、scss  
2、style的scope扩展  
3、自定义块(顶级标签)，如i18n、GraphQl的page-query  
### Vue SFC编译过程
1、source Code，parse,得到template AST、javascript AST、css AST  
2、基于AST做很多处理：代码转换、（代码检查、依赖分析、作用域分析）、优化、浏览器兼容、动态polyfill加载、代码压缩、代码混淆
、代码测试覆盖率检查、热重载、条件编译、linting、代码重构、错误追踪  
3、组合为目标组件代码，component assets
### DSL
领域特定语言，对应GPL通用编程语言
### CSP
内容安全策略
### 模板预编译好处
1、DSL针对性优化  
2、运行时体积减小  
3、性能提升  
4、避免CSP相关问题
### 模板预编译期优化
1、能静态就静态，能少更新就少更新  
静态指数提取，不变的部分提取成renderStatic，静态字符串,虚拟dom更新时可以直接跳过  
staticClass提取  
jsx是完全js的语法，我们无法知道哪儿些是静态的，而在模板中可以知道的。    
2、新语法支持，独立于js,不依赖于babel的更新。  
3、改造renderh函数的with语法（淘汰、性能低），用新定义的_vm变量替换；这样可以提升性能和增加沙盒控制  
### 职责委派，webpack pitch查找和execute执行
先查找1style-loader、2css-loader、3postcss-loader;然而执行是3、2、1  
### scoped css原理
生成scope ID=>分别注入对应的css选择器、模板AST
### css modules，用法和原理
1、常规的css 写法  
2、提取其中class选择器  
3、注入$style变量  
4、在模板中访问$style  
这样就可分scope和模块化了。  
react 下用的css in js  vs css module
### 基于模板编译时的AST，做intelligence智能语法提示
### 定制SFC格式
1、处理AST中node.type==2(文字)、node.text  
2、在webpack配置，给vue-loader，改配置，加入上面处理ast的函数  
### 原生SFC草案如果通过和实现，我们就可在浏览器运行时实现这些功能了。
### 工程化优秀的探索
1、同时考虑编译时和运行时的优化。
2、既要支持高手们有大量工具辅助的高阶优化，又要支持新手的零配置、零基础、零知识的上手。
## 第四天，前端工程化的探索实践
### 发际线法则、黄金圈法则
1、普通人，what=>how=>why，从外到内
2、成功人，why=>how=>what,从内到外
### 工程化的目的
流程管控、更安全、稳定=》自动化、提升效率=》本质，工程师自我的救赎，提升自己效率解放自己。
### 工程化应用框架包括：业务、用户、权限、流程
### 工程化基础研发体系：设计、研发、测试、部署、监控
### 业界可视化自动化前端工程化一站式成品：宜搭/飞冰/BigFish/Strikingly/Wix
生态体系、概念  
后端比前端=20:1,解放前端，所以为了降低前端开发的开发压力。
### 一站式平台覆灭?与底层耦合，如vue、react,不灵活、不容易响应变化
1、需求变了<=有更高的体验要求  
2、底层变了，浏览器底层api变了 <=有更好的技术支撑  
3、打造新的基础设施  
1=>2=>3=>1=>2=>3.....
如何避免？  
技术决策：
1、UI数据是一切的基础，可全局读写  
2、任何联动都可以转化成第三方数据的映射 
### 一站式成本？  
webIDE：模块依赖框架、IDE通用模块（弹出、弹窗等）、业务模块。小步快跑，底层可复用；webIDE自举，开发自己页面；  
文档等辅助能力，通过静态分析，实现文档自动化；提交时检查哪儿些缺少文档，提醒加文档，规范格式；webide,加速搭建组件demo页面。  
自动化测试等下游设施  
### 程序=算法+数据，调用栈仿照事件栈
需求的自然语言=>结构化需求语言=>可生成需求代码=>代码与需求的关联搜索  
人工智能方向    
白盒代码流派  人工可以干预可读，机器需要对人类认知达到一定程度的理解  
黑盒代码流派  无法人工干预，无法确保99次对了，100次还对？  
小范围内用黑盒代码，最外层用白盒代码  
### 简单的方式才是最难的方式，现在看起来难的方式将来会越来越简单
## 第五天，从蚂蚁金服的前端框架和工程化实践学习
### 技术、人、插件体系
使用框架的人，可以参与贡献，反哺框架。  
bigfish五层架构：依赖层（vue、react、webpack、babel等）、插件层（内部插件、社区插件）、插件集层（babel preset等）、应用类型层（spa、MPA、ssr、微前端等）、部署模式层（java框架、node框架、纯静态资源等）  
#### 插件生命周期
编译时node、运行时浏览器、编辑时UI辅助  
编译时：读取环境变量、读取插件、读取配置、生成路由配置、生成webpack配置、编译webpack
、生成html、启动devServer  
运行时：读取运行时插件、获取路由、获取根节点、渲染页面...  
### 紧贴业务，打通流程
项目的两个维度：  
appType:应用类型，如spa  
deployMode:部署模式，如node  
### 开源
代码质量  
bugfix  
额外的代码贡献  
开发群  
### 组件化分层
通用组件、业务组件、区块、页面模板
### 资产市场，打通上下游
设计师：设计师工具  
开发者和使用者：官网、命令行工具、组件打包工具、可视化工具  
### 微前端关键技术实现
css隔离、js沙箱eval、按需加载、公共依赖加载  
开源框架：乾坤+umi-plugin-qiankun  
### 场景完备性
SPA、MPA、SSR、微前端、多SPA、prerender  
node框架、java框架、静态资源、离线包、静态站点










