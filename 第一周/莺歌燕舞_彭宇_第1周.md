# 第一周学习笔记
### 一、支付系统中有那些技术问题可能会引发资金损失
1. 网络问题
- 网络一层一般进去catch处理，走失败分支，银行可能是成功、失败、处理中，若是成功商户再发起就会重复扣款
- 方案：设置为处理中状态，等待定时查询或通知返回最终状态
2. 查询和通知问题
- 查询失败、查询异常不代表交易最终是失败的，特别是第三方查询交易接口返回失败，这是订单查询失败，不是交易本身失败，若误设置为订单失败，则可能引发重复扣款
- 查询频率过快，第三方还没处理好，查询无订单
- 被查询接口幂等性问题，银行T+1和T状态不一样
- 通知：上游或下游重复通知、或前后两次通知不一致，以第一次为准，不一样预警
- 接口幂等性，上游订单交易流水号做幂等，或入口redis防重
- 状态同步问题，支付系统依赖下游系统，支付订单的最终状态也完全依赖下游系统，根据订单状态解析响应码
- 查询订单不存在的单独设置响应码 做特殊报警处理
- 付款类的交易不可设置为失败
- 重复提交问题，以上问题会产生重读提交，间接影响
3. 直接原因：
- 并发导致重复支付，
- 表单重复提交导致重复支付，点击两次提交
- 定时器重复执行
- 重试机制导致，mq、http都有重试机制
> 总结
- 归根到底来说就是前后端防重问题
- 前端：JS禁掉提交按钮、数据库加索引、redis加锁、token校验等
- 后端：数据库乐观锁+有限状态机+白名单，其中数据库乐观锁控制并发，白名单控制状态机的流转（不能是黑名单机制）


### 二、如何实现数据异构的多级缓存策略
> 数据异构的实现 
1. 双写
- 先写数据库，写ES时不能放到mysql事务中，mysql事务会保持数据库连接，若放进去高并发ES可能把数据库连接池耗尽导致瘫痪，以mysql数据为准，再写ES，若写ES失败了无法通过事务回滚就会丢失
2. MQ
- 引入中间件增加数据不一致概率，还降低查询性能，切面拦截一道再由mq发送消息，系统接受再写入缓存效率低
- 线程池也增加丢消息概率，重启时消息没发来，MQ还需要自己实现数据异构逻辑
- 优势：MQ将数据异构的逻辑与业务逻辑解构，提升代码可维护性，通过MQ的重试机制可以提升数据异构写入数据的成功率
3. Binglog
- 由于是串行，一个阻塞就会出问题，所以常采用订阅从库的binlog，但又降低了查询性能

> 多级缓存的实现
- 建议采用双写实现数据异构，双写的优势：多个数据表可以异构到一个表
- 若采用MQ或binlog 则只能通过监听订单表，并再异构时反查数据库获取订单详情表数据，才能实现完整的数据异构，不仅增加数据库查询压力也增加了复杂度
- 缓存设计采用的是保持用户N条记录，当查N+1时会出现缓存穿透查询数据库，数据库是全量数据
- 由于双写存在数据不一致问题，数据订正很重要，每几分钟进行一次增量校对，每晚进行一次全量校对，保证数据一致
- 若缓存查询命中率很高，用限定性查询，不在范围内的查询数据库


### 三、缓存穿透、并发使用的解法有哪些？
1. 高并发下不建议设置缓存过期
2. 缓存穿透，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，利用不存在的key频繁攻击应用是漏洞,解决方案：
- 预设值，不存在的key设置值null，再次还是null,说明key无效
- 布隆过滤器,guava库中包含
3. 缓存并发，同一个数据并发查询，导致并发查询数据，解决：缓存中没得数据查询时设置标识
4. 缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。
5. 缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。
这个和缓存雪崩的区别在于这里针对某一key缓存，前者则是很多key。



### 四、如何使用Postman做接口自动化测试
1. 通过npm及js使用及编写预处理脚本
2. 集成jenkins完成自动化测试

### 五、如何利用反射和泛型编程让你的Java代码更优雅
1. 反射是程序运行时，访问或修改类和方法行为的一种机制，能够减少重复代码
2. 统一实现的泛型模板类可以兼容多种类型POJO
3. 代码逻辑得到了更好的抽象，重复代码减少，项目迭代速度加快
4. 项目中的专家来实现泛型模板类，小白可以拿来即用，减少人为编码错误


### 六、如何从java线程内存模型分析线程是否安全
1. 线程安全：Vector、HashTable、StringBuffer
2. 线程不安全：LinkedList，ArrauList、HashMap、StringBuilder
3. volatile不是锁，不能保证线程安全
4. volatile可以提升性能，但不能保证线程安全
5. Collections.synchronizedList、Collections.synchronizedMap包装使其线程安全


### 七、人工智能技术在金融行业应用探索
1. DDOS攻击预防
2. 手写笔迹识别、电子合同
3. 安全登陆、加密技术、反欺诈系统风险分析预警应用
4. 大数据反欺诈风险识别

### 八、如何快速深入学习一门新技术
1. 快速阅读，掌握大量思想
2. 深入细节内容，通过案例实践
3. 通过微服务将案例整合到一个项目中
4. 偏理论知识通过碎片化时间学习知识点
5. 偏实践知识通过先实践再了解原理

### 九、怎样避免将中台做成平台
1. 对前台业务的快速响应能力
2. 企业级能力的复用能力
3. 从前台、中台到后台的设计研发、页面操作、流程服务和数据的无缝联通和融合能力

