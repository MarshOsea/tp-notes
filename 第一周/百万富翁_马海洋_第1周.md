## 每日一课学习笔记

### 2020/02/10

#### JVM问题定位典型案例分析

##### 01 类加载死锁

线程Dump没有检测到死锁，但有不少的线程Block在Class.XXXX这个方法上，然而Class.XXXX并没有加锁，Java级别的锁会在jstack <pid> 的输出最后看到。

##### 02 FinalReference堆积

通过jmap -histo 可知java.lang.ref.Finalizer对象排在第一，FinalReference外面无法扩展，Finalizer是FinalReference的子类，类加载的时候根据类里是否含有非空的void finalize()方法来决定是否其对象将来被一个FinalReference对象引用。

GC发生并找出Finalizer对象，判断Finalizer对象引用的对象是否没有别的引用了，将引用已死对象的Finalizer对象丢到一个Finalizer的ReferenceQueue里，在GC结束之后，FinalizerThread线程被唤醒并从ReferenceQueue里取出来间接调用finalize方法。

执行完finalize方法后会剥离Finalizer对象和被引用对象的关系，执行完了finalize方法的Finalizer对象及被引用的对象会在下个GC周期里被回收，如果finalize方法因为队列过长，不得不等待之前的对象执行完才能执行，因此可能存在跨多个GC周期。

对于重载了 Object 类的 finalize 方法的类实例化的对象（这里称为 f 对象），JVM 为了能在 GC 对象时触发 f 对象的 finalize 方法的调用，将每个 f 对象包装生成一个对应的FinalReference 对象，方便 GC 时进行处理。

##### 03 堆外内存泄露

heap使用率很低，但是出现了OOM或者FullGC，如果是java滥用所致，可以使用btrace跟踪DirectByteBuffer的构造函数来定位，非java层面的问题，可以使用google perftools来分析具体哪里分配，比如压缩解压缩。

##### 04 YGC不断拉长

YGC主要分三步骤，mark、copy、sweep，mark和copy是同时进行的，被mark的对象多少直接影响了耗时的多少。

StringTable主要记录了经过了String.interm后的String对象指针，SystemDictionary主要是记录了加载的类，两者都是hashTable结构，因此存在hash碰撞的风险。

类卸载或者StringTable清理在CMS GC或者Full GC的时候才会清理，通过jmap -histo:live <pid> 触发一次Full GC，如果发现接下来的YGC的时间变短了，那说明和这两块的可能性比较大

### 2020/02/11

#### 唯品会微服务架构演进之路

##### 唯品会微服务架构体系总体介绍

唯品会围绕微服务框架体系，自研了一系列的微服务基础中台，包括 OSP 微服务框架、服务治理中心、配置中心、全链路监控、API 网关、服务安全管理、分布式协调等，同时基于 Kubernetes+Docker 技术框架研发了云平台，涵盖应用的开发、交付、运维和运营全生命周期，OSP 独创性的 proxy 代理架构，将治理能力完全从客户端剥离，并结合容器云平台迅速演进为 Service Mesh 部署架构。

##### 唯品会微服务架构最佳实践

###### 业务驱动原则

- 识别核心业务域，形成基础业务能力
- 根据业务定位、范围、边界进行服务的划分
- 首先关注服务的业务范围，而不是服务的数量、粒度

###### 服务分层原则

- 划分基础、聚合、流程服务
- 基础服务贴近业务实体，提供业务的基础能力
- 聚合服务聚合基本业务场景，满足高一层业务场景并可复用
- 流程服务面向复杂业务流程实现，通过驱动多个聚合/基础服务实现一个完整的业务流程

###### 服务松耦合原则

- 服务职责单一，一个服务聚焦在特定业务的有限范围内，有助于敏捷开发和独立发布
- 区分核心业务服务和非核心业务服务
- 区分稳定服务和易变服务
- 每个服务只能访问自己的数据

###### 服务独立部署原则

- 服务独立部署，能够独立发布或取消发布
- 服务可水平扩展，并支持单独扩展
- 实现持续集成和自动发布
- 实现服务的技术和业务监控

###### 兼容性原则

- 接口契约先行，提供最新在线服务文档
- 服务版本管理，保证向前兼容

### 2020/02/12

#### 阿里妈妈广告排序算法创新之旅

##### 技术背景

CTR（Click-Through-Rate）即点击通过率，是互联网广告常用的术语，指网络广告（图片广告/文字广告/关键词广告/排名广告/视频广告等）的点击到达率，即该广告的实际点击次数除以广告的展现量。点击率预估（Click-Through Rate Prediction）是互联网主流应用(广告、推荐、搜索等)的核心算法问题，包括Google、Facebook等业界巨头对这个问题一直进行着持续投入和研究。
CTR预估是互联网计算广告中的关键技术环节，预估准确性直接影响公司广告收入。广告领域的CTR预估问题，面临的是超高维离散特征空间中模式发现的挑战——如何拟合现有数据的规律，同时又具备推广性。

##### MLR在阿里妈妈业务应用现状

从2013年起，MLR算法在阿里妈妈及阿里集团多个BU的主要场景(包括阿里妈妈精准定向广告、淘宝客、神马商业广告、淘宝主搜等等）被大规模地应用和尝试，尤其是在阿里妈妈的精准定向广告场景，算法模型创新带来了业务上的重大突破，主要场景下的CTR和RPM均获得20%以上的提升。典型应用如下：

###### 基于MLR的定向广告CTR预估算法

基于MLR算法的非线性学习能力，阿里妈妈的定向广告CTR预估采用了大规模原始ID特征+MLR算法的架构。具体地，我们刻画一次广告展现为特征向量，它由三部分独立构成：用户部分特征（包括userid、profile信息、用户在淘宝平台上的历史行为特征（浏览/购买过的宝贝/店铺/类目上的id和频次等）、广告部分特征（包括adid、campainid、广告对应的卖家店铺id、类目id等）、场景部分特征（包括时间、位置、资源位等）。这些特征之间无传统的交叉组合，维度在2亿左右。然后我们将数据直接喂给MLR算法，并且应用了结构化先验、pretrain+增量训练、线性偏置等高级技巧，让模型从数据中自动去总结和拟合规律。实践证明，相比于传统的LR+特征工程思路，这种解法更为高效和优雅，模型精度更高，在实际生产中的可迭代更强。

###### 基于MLR的定向广告Learning to Match算法

Match算法是定向广告中的一个重要环节，它的核心使命是基于用户的人口属性、历史行为等信息来猜测用户可能感兴趣的广告集合。传统的Match算法更多采用的是规则匹配、协同过滤等方法，方法的扩展性不强。在阿里妈妈定向广告系统中，我们研发了基于MLR的learning to match算法框架。简单来说，用模型的方法基于用户的行为历史来学习用户个性化的兴趣，从而召回高相关性的候选广告集。同样地，基于MLR算法的非线性能力，我们可以很容易地将不同的特征源、标签体系融合到框架中，不需要过多地关注和设计特征的交叉组合，使得框架的灵活性大大增强。

### 2020/02/13

#### GraalVM及其生态系统

Graal 是一个用 Java 编写的高性能即时编译器。它是 Java 9 中 AOT 编译的实现基础，并将作为试验性即时编译器与 Java 10 一同发布。GraalVM 拥有自己的生态系统，为各类托管语言（如 Java，JavaScript，Ruby 及 R）提供优越的峰值性能。Graal 可以在通用的 Java HotSpot 虚拟机或 SubstrateVM 上运行。后者是 GraalVM 为了实现高启动性能，低 memory footprint 而提供的解决方案。

##### GraalVM 组成部分

- Graal： 动态的实时（JIT）编译器，通过独特的代码分析和优化方法，能够提升应用程序的效率和速度。
- Graal Polyglot APIs：APIs用来在共享运行时间里绑定编程语言。这些APIs可以根据你的需求去匹配编程语言，并且只需很少的资源就可以达到更好的性能。
- Graal SDK：一组高效的APIs集合，用于嵌入式Graal语言以及配置本机镜像。
- Oracle HotSpot Java Virtual Machine (JVM)：针对那些基于JVM的语言或者支持非宿主编程语言提供的一个运行时环境。

##### Graal 编译器的特性

- 高性能的现代Java
- 占用资源少，启动速度快
- JavaScript, Java, Ruby以及R混合编程
- 在JVM上运行原生语言
- 跨语言工具
- JVM应用扩展
- 原生应用扩展
- 本地Java库
- 数据库支持多语言
- 创建自己的语言

### 2020/02/14

#### 从零到一构建基于对抗性训练的广告流量反作弊系统

近些年，国内移动网络广告行业取得了爆发性的发展。面对这 7000 亿元的庞大市场，大量广告刷量黑产团伙也嗅到了这庞大利润，不断涌入广告市场进行大肆破话。据数据统计 2018 年虚假广告流量占总广告流量 30%，广告主一年损失约 260 亿人民币。而对抗黑产，反作弊的路上也充满了荆棘。随着反作弊团队打击力度加大，黑产作案手段与技术也不断地提高，有时候为了迷惑广告主，甚至会在业务表象数据上模拟真实用户，达到以假乱真的效果。

面对黑产不断地演进，反作弊团队不能墨守成规，必须灵活应对黑产不断变换“姿势”地一波又一波的攻击。这是一个攻防的过程，也是反作弊团队对抗性学习的过程。为此我们研发出一套可对抗性学习提升的广告流量反作弊查杀系统。

对于广告黑产不断变换姿态攻击广告平台，不断查找漏洞试图避开反作弊团队布下的层层防御设施，反作弊团队不能一直被动防守，要主动出击，主动寻找黑产的作弊方式。通过我们“查”模块，系统主动发现大量聚集且疑似刷量的行为，通过规则，情报与人工筛选锁定作案方式，并将相关信息记录至样本库当中。“杀”模块将“查”模块检测出的新的作弊方式融入模型训练当中。使我们的模型更全面地识别目前刷量行为。只要我们反作弊系统一直有流量进来，我们就能探测新的广告作弊方式，增强我们对虚假流量的识别能力，最终整个系统形成一个自我学习的良好闭环。


